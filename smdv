#!/usr/bin/python3

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

""" smdv: a simple markdown viewer """

## Imports.

# standard library
import os
import sys
import time
import argparse
import textwrap
import subprocess
import webbrowser
import http.client

# third party
import flask


## Constants.

HOME = os.path.expanduser("~")
SMDV_BROWSER = os.environ.get("SMDV_BROWSER", os.environ.get("BROWSER", ""))
SMDV_CSS = os.environ.get(
    "SMDV_CSS",
    "https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/3.0.1/github-markdown.css",
)
SMDV_JQUERY = os.environ.get(
    "SMDV_JQUERY", "https://code.jquery.com/jquery-3.4.1.min.js"
)
SMDV_HOME = os.path.abspath(os.path.expanduser(os.environ.get("SMDV_HOME", HOME)))
SMDV_PORT = os.environ.get("SMDV_PORT", "9876")


## Argument parser
parser = argparse.ArgumentParser(description="simple markdown viewer")
parser.add_argument(
    "filename", type=str, nargs="?", help="path or file to open with smdv"
)
group = parser.add_mutually_exclusive_group()
group.add_argument(
    "-d",
    "--daemon-start",
    action="store_true",
    default=False,
    help="start daemon; all other arguments will be ignored",
)
group.add_argument(
    "-s",
    "--daemon-status",
    action="store_true",
    default=False,
    help="check daemonstatus",
)
group.add_argument(
    "-D",
    "--daemon-stop",
    action="store_true",
    default=False,
    help="stop daemon; all other arguments will be ignored",
)
group.add_argument(
    "-r", "--reload", action="store_true", default=False, help="reload active webpage"
)


## Blueprints.

bp = flask.Blueprint(
    "blueprint", __name__, static_folder=SMDV_HOME, static_url_path="/@static"
)


## Tools and functions.


def browser_open(filename=""):
    """ spawn a new browser and open the specified file """
    url = os.path.abspath(os.path.expanduser(args.filename)).replace(
        SMDV_HOME, f"http://localhost:{SMDV_PORT}"
    )
    print(f"smdv: opening browser at {url}")
    with open(os.devnull, "w") as NULL:
        if SMDV_BROWSER == "chromium --app":
            subprocess.Popen(["chromium", f"--app={url}"], stdout=NULL, stderr=NULL)
        elif SMDV_BROWSER:
            subprocess.Popen([SMDV_BROWSER, url], stdout=NULL, stderr=NULL)
        elif subprocess.call(["which", "xdg-open"], stdout=NULL, stderr=NULL) == 0:
            subprocess.Popen(["xdg-open", url], stdout=NULL, stderr=NULL)
        else:
            webbrowser.open(url)


def create_app():
    """ flask app factory """
    app = flask.Flask(__name__)
    app.register_blueprint(bp)
    return app


def daemon_start():
    print("smdv: starting daemon...")
    create_app().run(debug=True, port=SMDV_PORT, threaded=True)


def daemon_start_background():
    print("smdv: starting daemon...")
    with open(os.devnull, "w") as NULL:
        subprocess.Popen(["smdv", "--daemon-start"], stdout=NULL, stderr=NULL)


def daemon_status():
    connection = http.client.HTTPConnection("127.0.0.1", SMDV_PORT)
    try:
        connection.connect()
        status = "daemon running"
    except ConnectionRefusedError:
        status = "daemon stopped"
    finally:
        connection.close()
    print(f"smdv: {status}")
    return status


def daemon_stop():
    print("smdv: stopping daemon...")
    connection = http.client.HTTPConnection("127.0.0.1", SMDV_PORT)
    try:
        connection.connect()
        connection.request("GET", "/@daemon-stop")
        response = connection.getresponse().read().decode()
    except ConnectionRefusedError:
        response = "smdv: no daemon to stop."
    finally:
        connection.close()
    if (
        response == "smdv: server successfully stopped."
        or response == "smdv: no daemon to stop."
    ):
        print(response)
    else:
        raise RuntimeError(response)


def is_binary_file(filepathname):
    textchars = (
        bytearray([7, 8, 9, 10, 12, 13, 27])
        + bytearray(range(0x20, 0x7F))
        + bytearray(range(0x80, 0x100))
    )
    is_binary_string = lambda bytes: bool(bytes.translate(None, textchars))

    if is_binary_string(open(filepathname, "rb").read(1024)):
        return True
    else:
        return False


def reload():
    with open("/tmp/smdv_reload", "w") as file:
        file.write("reload required")


## Converters.


def body2html(body: str):
    """ convert a html body to full html

    Args:
        body: str: the html body

    Returns:
        html: str: the resulting html
    """
    stylesheet = SMDV_CSS
    if not stylesheet.startswith("http"):
        stylesheet = os.path.abspath(os.path.expanduser(stylesheet)).replace(
            SMDV_HOME, f"http://localhost:{SMDV_PORT}/@static"
        )
    jquery = SMDV_JQUERY
    if not jquery.startswith("http"):
        jquery = os.path.abspath(os.path.expanduser(jquery)).replace(
            SMDV_HOME, f"http://localhost:{SMDV_PORT}/@static"
        )
    html = textwrap.dedent(
        f"""
        <!DOCTYPE html>
        <html>
        <head>
        <link rel="stylesheet" href="{stylesheet}">
        <style>
            .markdown-body {{ box-sizing: border-box; min-width: 200px; max-width: 980px; margin: 0 auto; padding: 45px; }}
            @media (max-width: 767px) {{ .markdown-body {{ padding: 15px; }} }}
        </style>
        <script src="{jquery}"></script>
        </head>
        <body>
        <article class="markdown-body">
        {body}
        </article>
        <script>
            function queryReload() {{
            $.ajax({{
               url: "/@queryReload",
               success: function(data) {{
                      if (data == "true")
                         location.reload();
                      else
                         setTimeout(queryReload, 1000);
               }}
            }});
            }}
            setTimeout(queryReload, 1000);
        </script>
        </body>
        </html>
        """
    )
    return html


def dir2html(path, full=True):
    """ convert markdown to html using the github flavored markdown [gfm] spec of pandoc

    Args:
        path: str: the directory path

    Returns:
        html: str: the resulting html
    """
    if path.endswith("/"):
        path = path[:-1]
    url = lambda path: path.replace(SMDV_HOME, f"http://localhost:{SMDV_PORT}").replace(" ", "%20")
    filenames = {f"<h1>{path}</h1>": None}
    if path != SMDV_HOME:
        filenames.update({"<b>‚¨ÜÔ∏è  ..</b>": url(os.path.dirname(path))})
    listdir = sorted([p for p in os.listdir(path)], key=str.upper)
    md_html = ""
    for readme in ["README.md", "Readme.md", "readme.md"]:
        if readme in listdir:
            with open(os.path.join(path, readme), "r") as file:
                md_content = file.read()
            md_html = md2html(md_content, full=False)
    listdir = [os.path.join(path, p) for p in listdir]
    listdir = [p for p in listdir if os.path.isdir(p)] + [
        p for p in listdir if not os.path.isdir(p)
    ]
    filenames.update(
        {
            (
                f"<b>üìÅ  {os.path.basename(p)}</b>"
                if os.path.isdir(p)
                else f"üìÑ  {os.path.basename(p)}"
            ): url(p)
            for p in listdir
        }
    )
    html = "<br>\n".join(
        [f"<a href={u}>{p}</a>" if u is not None else p for p, u in filenames.items()]
    )
    if not full:
        return html
    if md_html:
        html = html + "<br><br><hr><br>" + md_html
    html = body2html(html)
    return html


def md2html(s: str, full=True):
    """ convert markdown to html using the github flavored markdown [gfm] spec of pandoc

    Args:
        s: str: the markdown string to convert

    Returns:
        html: str: the resulting html
    """
    md_out = subprocess.Popen(["printf", s.encode()], stdout=subprocess.PIPE).stdout
    html_out = (
        subprocess.check_output(
            ["pandoc", "--from", "gfm", "--to", "html"], stdin=md_out
        )
        .decode()
        .strip()
    )
    if not full:
        return html_out
    html = body2html(html_out)
    return html


## Routes.


@bp.route("/@queryReload")
def query_reload():
    """ query the server if the current page needs a reload """
    if os.path.exists("/tmp/smdv_reload"):
        os.remove("/tmp/smdv_reload")
        return "true"
    else:
        return "false"


@bp.route("/@daemon-stop")
def request_daemon_stop():
    """ kill flask server """
    func = flask.request.environ.get("werkzeug.server.shutdown")
    if func is None:
        return f"could not stop server on port {SMDV_PORT}."
    func()
    return "smdv: server successfully stopped."


@bp.route("/<path:path>.md")
def view_md(path):
    """ view markdown file """
    path = os.path.join(SMDV_HOME, path + ".md")
    with open(path, "r") as file:
        md = file.read()
    html = md2html(md)
    return html


@bp.route("/")
@bp.route("/<path:path>")
def view_other(path=""):
    """ view file/directory

    Args:
        path: the path of the file or directory to show

    Note:
        This is the default route. Any filetype that has no route of its own
        will be opened here.
    """
    path = os.path.join(SMDV_HOME, path)
    if not os.path.exists(path):
        flask.abort(404)
    elif os.path.isdir(path):
        return dir2html(path)
    elif not is_binary_file(path):
        with open(path, "r") as file:
            content = file.read()
        return md2html(f"```\n{content}\n```")
    else:
        return flask.redirect(
            path.replace(SMDV_HOME, f"http://localhost:{SMDV_PORT}/@static")
        )


## Script.

if __name__ == "__main__":
    try:
        # parse and validate arguments
        args = parser.parse_args()

        # daemon (server) control

        if args.daemon_start:
            daemon_start()
            exit(0)

        if args.daemon_stop:
            daemon_stop()
            exit(0)

        if args.daemon_status:
            daemon_status()
            exit(0)

        if args.reload:
            reload()
            exit(0)

        # open daemon in subprocess. (or let it fail if a daemon is already running)
        if daemon_status() == "daemon stopped":
            daemon_start_background()
            time.sleep(1)  # give time for the daemon to spawn

        # open webbrowser for file:
        browser_open(args.filename)

    except Exception as e:
        print(f"{e.__class__.__name__}: {str(e)}", file=sys.stderr)
        exit(1)
